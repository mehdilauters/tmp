symfony new gitlab-symfony --full
cd gitlab-symfony

mkdir docker
cd docker
# copy the content of https://gitlab.com/ramet/environnement-de-developpement-symfony-5-avec-docker-et-docker-compose

# set docker-compose.yml
version: "3.8"
services:

    db_gitlab:
        image: mysql
        container_name: db_docker_gitlab
        restart: always
        volumes:
            - db-data:/var/lib/mysql
        environment:
            MYSQL_ALLOW_EMPTY_PASSWORD: 'yes'
        networks:
            - dev

    www_gitlab:
        build: php
        container_name: www_docker_gitlab
        ports:
          - "8080:80"
        volumes:
            - ./php/vhosts:/etc/apache2/sites-enabled
            - ../:/var/www
        restart: always
        networks:
            - dev

networks:
    dev:

volumes:
    db-data:

# set vhost.conf
<VirtualHost *:80>
    ServerName localhost

    DocumentRoot /var/www/public
    DirectoryIndex /index.php

    <Directory /var/www/public>
        AllowOverride None
        Order Allow,Deny
        Allow from All

        FallbackResource /index.php
    </Directory>

    # uncomment the following lines if you install assets as symlinks
    # or run into problems when compiling LESS/Sass/CoffeeScript assets
    # <Directory /var/www/project>
    #     Options FollowSymlinks
    # </Directory>

    # optionally disable the fallback resource for the asset directories
    # which will allow Apache to return a 404 error when files are
    # not found instead of passing the request to Symfony
    <Directory /var/www/public/bundles>
        FallbackResource disabled
    </Directory>
    ErrorLog /var/log/apache2/project_error.log
    CustomLog /var/log/apache2/project_access.log combined

    # optionally set the value of the environment variables used in the application
    #SetEnv APP_ENV prod
    #SetEnv APP_SECRET <app-secret-id>
    #SetEnv DATABASE_URL "mysql://db_user:db_pass@host:3306/db_name"
</VirtualHost>

docker-compose up -d
# open  http://127.0.0.1:8080/

# set database in symfony .env
DATABASE_URL="mysql://root:@db_gitlab:3306/db_name?serverVersion=5.7"

# Créons la base de donnée depuis la CLI de Symfony. Pour nous simplifier les prochaines commandes, nous allons entrer dans le shell du conteneur “www”.
docker exec -it www_docker_gitlab bash
> /var/www# php bin/console doctrine:database:create

# Mettons en place une entité "Demo" avec un champ "demo" de type string (et toutes les valeurs par défaut proposés par le Maker Bundle de Symfony), créons la migration associée puis exécutons la migration.
> /var/www# php bin/console make:entity Demo
> /var/www# php bin/console make:migration
> /var/www# php bin/console doctrine:migrations:migrate

# Création d’un dépôt GitLab et premier commit

# git init
git remote add origin git@gitlab.com:ramet/gitlab-symfony.git
git add .
git commit -m "Initial commit"
git push -u origin master

# Écriture d’un test unitaire (UnitTest)
> /var/www# php bin/console make:unit-test

# Éditons le fichier tests/UnitTest.php et ajoutons-y un test unitaire.
<?php

namespace App\Tests;

use App\Entity\Demo;
use PHPUnit\Framework\TestCase;

class UnitTest extends TestCase
{
    public function testDemo()
    {
        $demo = new Demo();

        $demo->setDemo('demo');

        $this->assertTrue($demo->getDemo() === 'demo');
    }
}

# Test pour vérifier qu’il fonctionne.
> /var/www# php bin/phpunit

git add .
git commit -m "ajout test unitaire"
git push

# Mise en place du Pipeline GitLab CI

touch .gitlab-ci.yml

# Using docker image jakzal/phpqa:php8.1
# - Check des failles de sécurité des dépendances avec Security Checker
# - Vérification du “style” de code avec PHP CS
# - Analyse statique avec PHP Stan
# - Analyse statique des fichiers Twig avec Twig-lint
# - Exécution de tests unitaires avec PHP Unit

git add .
git commit -m "Ajout de la pipeline"
git push

# Ajouter des tests fonctionnels avec interaction avec une base de données MySQL

cp .env.test .env.test.local

# Editer le fichier .env.test.local
# .env.test.local
KERNEL_CLASS='App\Kernel'
APP_SECRET='$ecretf0rt3st'
SYMFONY_DEPRECATIONS_HELPER=999999
PANTHER_APP_ENV=panther
DATABASE_URL="mysql://root:@db_gitlab:3306/db_test?serverVersion=5.7"

# Créons la base de données de test, et jouons-y les migrations
> /var/www# php bin/console doctrine:database:create --env=test
> /var/www# php bin/console doctrine:migrations:migrate --env=test

# Générons un CRUD (entité "Demo") pour avoir de quoi tester
> /var/www# php bin/console make:crud
# open http://127.0.0.1:8080/demo/

# Générons un test fonctionnel (FunctionalTest)
> /var/www# php bin/console make:functional-test

# Et éditons le fichier pour y écrire un premier test qui vérifie que l’url /demo répond bien
# Éditons le fichier tests/FunctionalTest.php
<?php

namespace App\Tests;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

class FunctionalTest extends WebTestCase
{
    public function testShouldDisplayDemoIndex()
    {
        $client = static::createClient();
        $client->followRedirects();
        $crawler = $client->request('GET', '/demo');

        $this->assertResponseIsSuccessful();
        $this->assertSelectorTextContains('h1', 'Demo index');
    }
}

# Ajoutons un deuxième test qui charge le formulaire d’ajout

public function testShouldDisplayCreateNewDemo()
    {
        $client = static::createClient();
        $client->followRedirects();
        $crawler = $client->request('GET', '/demo/new');

        $this->assertResponseIsSuccessful();
        $this->assertSelectorTextContains('h1', 'Create new Demo');
    }

# Enfin ajoutons un test qui va insérer des données via le formulaire, puis vérifier que celles-ci existent bien

    public function testShouldAddNewDemo()
    {
        $client = static::createClient();
        $client->followRedirects();
        $crawler = $client->request('GET', '/demo/new');

        $buttonCrawlerNode = $crawler->selectButton('Save');

        $form = $buttonCrawlerNode->form();

        $uuid = uniqid();

        $form = $buttonCrawlerNode->form([
            'demo[demo]'    => 'Add Demo For Test' . $uuid,
        ]);

        $client->submit($form);

        $this->assertResponseIsSuccessful();
        $this->assertSelectorTextContains('body', 'Add Demo For Test' . $uuid);
    }

# Pour terminer, validons que nos tests fonctionnent
> /var/www# php bin/phpunit --testdox

# Modifier le fichier .gitlab-ci.yml

phpunit:
    image: php:8.1-apache
    stage: UnitTests
    services:
        - name: mysql:5.7
          alias: mysql
    variables:
      MYSQL_ROOT_PASSWORD: pass_test
      MYSQL_DATABASE: myapptest
      MYSQL_USER: myapptest
      MYSQL_PASSWORD: myapptest
      DATABASE_URL: 'mysql://myapptest:myapptest@mysql:3306/myapptest'
    before_script:
        - apt-get update && apt-get install -y git libzip-dev
        - curl -sSk https://getcomposer.org/installer | php -- --disable-tls && mv composer.phar /usr/local/bin/composer
        - docker-php-ext-install mysqli pdo pdo_mysql zip
        - php bin/console doctrine:database:drop --force --env=test
        - php bin/console doctrine:database:create --env=test
        - php bin/console doctrine:migration:migrate --env=test --no-interaction
    script:
        - php bin/phpunit
    allow_failure: false

# Éditons le fichier .env.test pour indiquer à Symfony qu’elle base de données il doit utiliser dans le contexte d’exécution des tests
# .env.test
KERNEL_CLASS='App\Kernel'
APP_SECRET='$ecretf0rt3st'
SYMFONY_DEPRECATIONS_HELPER=999999
PANTHER_APP_ENV=panther
DATABASE_URL=mysql://myapptest:myapptest@mysql:3306/myapptest

git add .
git commit -m "Ajout des tests fonctionnels"
git push

# Vous devriez peut-être avoir un le fichier /src/Controller/DemoController.php qui ne passe pas le contrôle PSR-12 de PHP CS, je vous laisse faire la modification signalée (il manque des espaces autour d’un “.” en ligne 72) et refaire un commit + push.
